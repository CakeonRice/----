//=============================================================================
//
// エネミー処理 [enemy.cpp]
// Author : 
//
//=============================================================================
#include "enemy.h"
#include "texture.h"
#include "sprite.h"
#include "input.h"

//*****************************************************************************
// マクロ定義
//*****************************************************************************


//*****************************************************************************
// プロトタイプ宣言
//*****************************************************************************


//*****************************************************************************
// グローバル変数
//*****************************************************************************
static int	g_EnemyTexture = 0;
static ENEMY g_Enemy;							// エネミー構造体


//=============================================================================
// 初期化処理
//=============================================================================
HRESULT InitEnemy(void)
{
	g_EnemyTexture = LoadTexture("data/TEXTURE/tako.png");

	// エネミー構造体の初期化
	
	
		g_Enemy.use   = true;
		g_Enemy.w     = 50.0f;
		g_Enemy.h     = 50.0f;
		g_Enemy.pos   = D3DXVECTOR2(SCREEN_WIDTH / 2 - 150.0f , SCREEN_HEIGHT / 2 - 100.0f);
		g_Enemy.rot   = 0.0f;

		g_Enemy.state = 0;
		g_Enemy.frame = 0;
	
	return S_OK;
}

//=============================================================================
// 終了処理
//=============================================================================
void UninitEnemy(void)
{

}

//=============================================================================
// 更新処理
//=============================================================================
void UpdateEnemy(void)
{
	for (int i = 0; i < 1; i++)
	{
		if (g_Enemy.use == true)		// このエネミーが使われている？
		{								// Yes	
			switch (g_Enemy.state)
			{
			case 0:
				g_Enemy.pos.x -= 1.0f;
				if (g_Enemy.frame > 50)
				{
					g_Enemy.state = 1;
					g_Enemy.frame = 0;
				}
				break;
			case 1:
				g_Enemy.pos.x += 3.0f;
				g_Enemy.pos.y += 3.0f;

				if (g_Enemy.frame > 20)
				{
					g_Enemy.state = 2;
					g_Enemy.frame = 0;
				}
				break;
			case 2:
				g_Enemy.pos.x -= 3.0f;
				if (g_Enemy.frame > 40)
				{
					g_Enemy.state = 3;
					g_Enemy.frame = 0;
				}
				break;
			case 3:
				g_Enemy.pos.x += 3.0f;
				g_Enemy.pos.y += 3.0f;
				if (g_Enemy.frame > 40)
				{
					g_Enemy.state = 4;
					g_Enemy.frame = 0;
				}
				break;
			case 4:
				g_Enemy.pos.x += 3.0f;
				if (g_Enemy.frame > 200)
				{
					g_Enemy.use = 0;
				}
				break;
			}

			// 回転させる
			if ((i % 2) == 0)
			{
				g_Enemy.rot += 0.05f;
			}
			else
			{
				g_Enemy.rot -= 0.05f;
			}

			//フレームの追加
			g_Enemy.frame++;
		}
	}

}

//=============================================================================
// 描画処理
//=============================================================================
void DrawEnemy(void)
{
	
	
		if (g_Enemy.use == true)
		{
			//エネミーの位置やテクスチャー座標を反映
			float px = g_Enemy.pos.x;	// エネミーの表示位置X
			float py = g_Enemy.pos.y;	// エネミーの表示位置Y
			float pw = g_Enemy.w;		// エネミーの表示幅
			float ph = g_Enemy.h;		// エネミーの表示高さ
			D3DXCOLOR col = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);

			// １枚のポリゴンの頂点とテクスチャ座標を設定
			DrawSpriteColorRotate(g_EnemyTexture,px, py, pw, ph, 0.0f, 0.0f, 1.0f, 1.0f, col, g_Enemy.rot);
		}
	
}

//=============================================================================
// エネミー構造体の先頭アドレスを取得
//=============================================================================
ENEMY *GetEnemy(void)
{
	return &g_Enemy;
}


//=============================================================================
// 敵の発生処理
//=============================================================================
void SetEnemy(D3DXVECTOR2 pos)
{
	// もし未使用のデータを探す
	
	
		if (g_Enemy.use == false)		// 未使用状態の敵データを見つける
		{
			g_Enemy.use = true;			// 使用状態へ変更する
			g_Enemy.pos = pos;			// 座標をセット
			g_Enemy.rot = 0.0f;			// 回転角のリセット
			g_Enemy.state = 0;			// 状態をリセット
			g_Enemy.frame = 0;			// フレームのリセット
			return;							// 敵をセットできたので終了する
		}
	
}

